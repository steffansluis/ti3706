Once the testing process has been organised to facilitate the particular software development method that is being used, the testing can finally begin. This chapter explains what data is relevant to the performance of software and how to collect that data in order to obtain the most accurate representation of the underlying performance. The first section is about the results of performance testing: performance counters. Then the different levels on which measurements can occur are explained. In the last section, it is discussed how accurately the test results represent the actual performance.

\section{Performance counters}
According to Zagha et al. performance counters provide a valuable insight into dynamic program behavior for applications, compilers, operating systems and hardware \cite{zagha1996performance}. They are used to measure events that occur during program execution. Examples are: the number of instructions, loads, bandwidth and the number of execution cycles. The goal of analyzing performance counters is to detect if a performance regression has occured, where the performance regression has occured, and what causes the regression \cite{nguyen2012using}.

In order to measure performance counters in practice, some steps have to be taken. First of all, a choice in performance counter has to be made. Depending on which performance counter was selected, an infrastructure for measuring the value of this counter needs to be set up. After a test run it could be useful to run the test again, but without selecting a performance counter, so that there are no influences of the test itself on the performance of the second run.

\section{Accuracy between different levels}
Performance can be monitored on various levels: system level, application level and functional level. The accuracy of a counter depends on the level it belongs to. If a counter measures performance on a system level it is hard to detect if performance regressions have occured. The reason for this is that a system level performance counter is more likely to fluctuate, since any anomaly in the system may affect it. For a counter measuring on the application level it is known that anomalies occur in a specific application. That means it is less likely to have been influenced by other factors and more likely to be a performance regression. If a counter belongs to the functional level, it is exactly known in which function a performance regression has occured. Finding the cause of the performance regression is a simple matter of looking at the changes in the function.

\section{Accuracy of performance metrics}
Performance counters can give an accurate representation of the performance of a system. However, there are some factors that can influence the accuracy of the representation obtained using performance metrics. In addition to being dependent of the software that is tested, performance counters also depend on the system configuration that is used and the events that are measured \cite{korn2001just}.

The accuracy of the representation of a systems performance becomes less accurate as the number of measured events increases. In order to have more accurate results, a test should not test too many events at the same time.
In addition to that, there is a difference in accuracy of performance counters with different system configurations. Many proccessors support conditional event counting. This means that a counter will only be incremented if the processor is running on a specific level. This can be user mode, kernel mode or both. When counting in both modes, the measurement error gets bigger if the duration of the benchmark gets longer \cite{AccuracyPerformanceCounter}. This means that in order decrease the measurement error, a shorter test duration should be used. For the user mode the duration of the benchmark does not matter. This is because of interrupts skewing the measurement results, that only occur in kernel event counts.

%Detecting regressions is not a discrete process. The measuring of performance is precarious. Because of the precariously measuring, using an accuracy method is often used. An accuracy method shows how close to the previous revisions the new one is. To be precise with this method it is best to run the test a many times as possible. This is however impractical, because it could possibly take months or even longer. A middle ground is needed in order for the testing to be practical.%

%If it is known that a performance regression has occured, the next problem is to detect where the performance regression has appeared. Big software systems consist of many types of components, and each component may have many instances. Detecting where the perfomance regressions have shown up is very difficult, because there are many performance counters for each instance of each component. This can be very time consuming.

%o detect if a certain performance counter is the reason of performance regression, the state of the performance counter needs to be known. The state of a performance counter can be checked via a register. A register can be read or written via kernel-level processes. The states of two different tests need to be compared to check if performance regression has occured. These tests are a target run and a baseline run. The target run is the new test run, where the baseline run is a good prior run. On both tests equivalent performance counters can be used as input to detect if performance regressions have occured by comparing the output of the tests. Comparing the output of the tests is a big challenge, especially in big complex software systems.


%After determining the location of the performance regressions, the reason of the performance regressions needs to be determined. \textit{``Understanding the kind of problem usually requires static analysis of source code''} \cite{nguyen2012using}.
