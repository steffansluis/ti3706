Once the testing process has been organised to facilitate the particular software development method that is being used, the testing can finally begin. The next challenge that presents itself is what to test for. This chapter explains what data is relevant to the performance of software and how to collect that data in order to obtain the most accurate representation of the underlying performance.


\section{Performance counters}
\textit{``Performance counters provide a valuable insight into dynamic program behavior for applications, compilers, operating systems and hardware.''}\cite{zagha1996performance}
They are used to measure events that occur during program execution. Examples are: the number of instructions, loads, bandwidth or the number of executed cycles.

\textit{``The goal of analyzing performance counters is to detect if a performance regression has occured, where the performance regression has occured, and what causes the regression''} \cite{nguyen2012using}.

Performance counters can be configured or accessed via ARM's debug tools or software calls. If software calls are used, some steps need to be taken. At first the performance counters should be disabled. After that the event type that the counter needs to count and the cycle counter tick rate need to be set. Next the performance counters should be reset and enabled. Then the function to profile will be called. After the test the performance counter should be disabled again, and the results can be read out. Finally there should be a check so that performance counters did not overflow. After all steps it could be necessary to repeat all steps from resetting the performance counters, but an empty function should be called instead of the profile function, so that the results from this profiling can be deducted from the origin results, so that there are no influences from enabling or disabling the performance counter or calling the profile function.

Despite all the positives of performance counters, there are also some disadvantages to performance counters. The number of available counters is limited, and since each counter can only measure one event type, only a few event types can be measured. The amount of available counters depends on the processor, for example a Cortex-A5 processor has three available counters, where a Cortex-A9 processor has six.

\section{Accuracy of performance metrics}
The fact that performance counters are often used by application developers shows that performance counters are very useful. However, performance counters are not that accurate. \textit{``The accuracy of performance counters depends upon the interface used, the application being measured, and the event being measured.''}\cite{korn2001just}

Also, the number of registers used in a test depends on the accuracy of a performance counter. Performance counters become less accurate as the number of registers increases. So to have reliable results, a test should not test too many registers. \cite{AccuracyPerformanceCounter}.

On top of that, the type of infrastructure is very dependent. The measurement error reduces a lot when a low-level infrastructure is used, instead of a high-level infrastructure. \cite{AccuracyPerformanceCounter}.

Finally, there is a difference in accuracy of performance counters with different counter configurations. Many proccessors support conditional event counting. This means that a counter will only be incremented if the processor is running a specific level. This can be user mode, kernel mode or user + kernel mode. On the user+kernel mode, the measurement error gets bigger if the duration of the benchmark gets longer. \cite{AccuracyPerformanceCounter} So in order to make the measurement error smaller, less loop iterations should be used. For the user mode the duration of the benchmark does not matter. This is because of interrupts, that only occur in kernel event counts.

%Detecting regressions is not a discrete process. The measuring of performance is precarious. Because of the precariously measuring, using an accuracy method is often used. An accuracy method shows how close to the previous revisions the new one is. To be precise with this method it is best to run the test a many times as possible. This is however impractical, because it could possibly take months or even longer. A middle ground is needed in order for the testing to be practical.%

%If it is known that a performance regression has occured, the next problem is to detect where the performance regression has appeared. Big software systems consist of many types of components, and each component may have many instances. Detecting where the perfomance regressions have shown up is very difficult, because there are many performance counters for each instance of each component. This can be very time consuming.

%o detect if a certain performance counter is the reason of performance regression, the state of the performance counter needs to be known. The state of a performance counter can be checked via a register. A register can be read or written via kernel-level processes. The states of two different tests need to be compared to check if performance regression has occured. These tests are a target run and a baseline run. The target run is the new test run, where the baseline run is a good prior run. On both tests equivalent performance counters can be used as input to detect if performance regressions have occured by comparing the output of the tests. Comparing the output of the tests is a big challenge, especially in big complex software systems.


%After determining the location of the performance regressions, the reason of the performance regressions needs to be determined. \textit{``Understanding the kind of problem usually requires static analysis of source code''} \cite{nguyen2012using}.
