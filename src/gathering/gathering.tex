Once the testing process has been organised to facilitate the particular software development method that is being used, the testing can finally begin. The next challenge that presents itself is what to test for. This chapter explains what data is relevant to the performance of software and how to collect that data in order to obtain the most accurate representation of the underlying performance. \\

Relevant data to measure performance can be represented by using performance counters. How performance counters measure performance and how to gather performance counters can be read in the next section.

\section{Performance counters}
According to Zagha, performance counters provide a valuable insight into dynamic program behavior for applications, compilers, operating systems and hardware \cite{zagha1996performance}. They are used to measure events that occur during program execution. Examples are: the number of instructions, loads, bandwidth or the number of executed cycles. The goal of analyzing performance counters is to detect if a performance regression has occured, where the performance regression has occured, and what causes the regression \cite{nguyen2012using}.

In order to measure performance counters in practice, some steps have to be taken. First of all, a choice in performance counter has to be made. Depending on which performance counter was selected, an infrastructure for measureing the value of this counter needs to be set up. After a test run it could be useful to run the test again, but without selecting a performance counter, so that there are no influences from enabling, disabling or calling the performance counter.

\section{Accuracy between different levels}
Performance can be monitored on various levels: system level, application level and functional level. The accuracy of a counter depends on the level it belongs to. If a counter is system level it is hard to detect if performance regressions have occured. If a test on a counter from system level shows that a performance regression has occured, the chance that this event changed because of other factors than performance regression is big. For a counter beloning to the application level it is known that the regression has occured in a specific application, so there is a big chance that performance regressions have occured. If a counter belongs to the functional level, it is exactely known in which function a performance regression has occured so it is quite easy to change this function.

\section{Accuracy of performance metrics}
The fact that performance counters are often used by application developers shows that performance counters are very useful. Performance counters can be very accurate, but they can also be very inaccurate. There are some factors that can influence the accuracy of performance metrics. {The accuracy of performance counters depends upon the interface used, the application being measured, and the event being measured}\cite{korn2001just}.

Also, the number of registers used in a test depends on the accuracy of a performance counter. Performance counters become less accurate as the number of registers increases. So to have more accurate results, a test should not test too many registers at the same time.

On top of that, the type of infrastructure is very dependent. The measurement error reduces a lot when a low-level infrastructure is used, instead of a high-level infrastructure.

Finally, there is a difference in accuracy of performance counters with different counter configurations. Many proccessors support conditional event counting. This means that a counter will only be incremented if the processor is running a specific level. This can be user mode, kernel mode or user + kernel mode. On the user+kernel mode, the measurement error gets bigger if the duration of the benchmark gets longer. \cite{AccuracyPerformanceCounter} So in order to make the measurement error smaller, less loop iterations should be used. For the user mode the duration of the benchmark does not matter. This is because of interrupts, that only occur in kernel event counts.

%Detecting regressions is not a discrete process. The measuring of performance is precarious. Because of the precariously measuring, using an accuracy method is often used. An accuracy method shows how close to the previous revisions the new one is. To be precise with this method it is best to run the test a many times as possible. This is however impractical, because it could possibly take months or even longer. A middle ground is needed in order for the testing to be practical.%

%If it is known that a performance regression has occured, the next problem is to detect where the performance regression has appeared. Big software systems consist of many types of components, and each component may have many instances. Detecting where the perfomance regressions have shown up is very difficult, because there are many performance counters for each instance of each component. This can be very time consuming.

%o detect if a certain performance counter is the reason of performance regression, the state of the performance counter needs to be known. The state of a performance counter can be checked via a register. A register can be read or written via kernel-level processes. The states of two different tests need to be compared to check if performance regression has occured. These tests are a target run and a baseline run. The target run is the new test run, where the baseline run is a good prior run. On both tests equivalent performance counters can be used as input to detect if performance regressions have occured by comparing the output of the tests. Comparing the output of the tests is a big challenge, especially in big complex software systems.


%After determining the location of the performance regressions, the reason of the performance regressions needs to be determined. \textit{``Understanding the kind of problem usually requires static analysis of source code''} \cite{nguyen2012using}.
